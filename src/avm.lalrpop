use std::str::FromStr;
use crate::{utils::unescape_string, parser::{Statement, Operand, TypeTag}, opcodes::{OPCODE_MAP, Opcode}};

grammar;

match {
    r"\s*" => { }, // Ignore whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Ignore // comments
    _,
} 

// The top level collection of statements, 
pub Statements: Vec<Statement> = {
    <ls:LabelOrStatement*> <s:Statement?> => ls.into_iter().flatten().chain(s).collect(), 
}

LabelOrStatement: Option<Statement> = {
    Label => Some(<>),
    <Statement?> ";" => <>
}

Statement: Statement = {
    IncludeStatement => <>,
    OpcodeStatement => <>,
    MacroStatement => <>,
    MacroInvocation => <>,
    ConstantDefinition => <>,
}

IncludeStatement: Statement = {
    ".include" <StringLiteral> => Statement::IncludeStatement(<>),
}


// TODO: parameters for macros
MacroStatement: Statement = {
    ".macro" <name:Identifier> "{" <statements:Statements> "}" => Statement::MacroStatement(name, statements),
}

MacroInvocation: Statement = {
    "$" <name:Identifier> => Statement::MacroInvocation(name),
}

Label: Statement = {
    <Identifier> ":" => Statement::Label(<>),
}

ConstantDefinition: Statement = {
    ".const" <name:Identifier> "=" <value:Operand> => Statement::ConstantDefinition(name, value),
}

// Opcode usage
OpcodeStatement: Statement = {
    // TODO: i feel that this could be trying to be too dynamic, do NOT remove this todo until solved
    <opcode:GetOpcode> <operands:Operand*> => Statement::OpcodeStatement(opcode, /*indirect=*/false, operands, None),
    <opcode:GetOpcode> "@"<label:Identifier> <operands:Operand*> => Statement::OpcodeStatement(opcode, /*indirect=*/false, operands, Some(label)),
    <opcode:GetOpcode> "!" <operands:Operand*> => Statement::OpcodeStatement(opcode, /*indirect=*/true, operands, None),
}

GetOpcode: Opcode = {
    <opcode:Identifier> => {
        let opcode = OPCODE_MAP.get(&opcode.to_lowercase()).expect("unknown opcode");
        *opcode
    }
}

Identifier: String = r"[a-z][a-zA-Z0-9_]*" => String::from(<>);

StringLiteral: String = {
    r#""[^\\"\n\r]*(\\[tnfbrx'"\\0-9][^\\"\n\r]*)*""# => unescape_string(<>)
}

Operand: Operand = {
    HexLiteral => Operand::Hex(<>),
    DecimalLiteral => Operand::Decimal(<>), 
    TypeTagLiteral => Operand::Tag(<>),
    Variable => Operand::Variable(<>),
}

TypeTagLiteral: TypeTag = {
    "u8" => TypeTag::U8,
    "u16" => TypeTag::U16,
    "u32" => TypeTag::U32,
    "u64" => TypeTag::U64,
    "u128" => TypeTag::U128,
    "ff" => TypeTag::FF,
}

Variable: String = "$"<Identifier> => <>;

HexLiteral: String = r"0x[a-f0-9]+" => String::from(<>);

// Number definition
DecimalLiteral: u64 = <s:r"[0-9]+"> => u64::from_str(s).unwrap();
