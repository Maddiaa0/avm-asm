use std::str::FromStr;
use crate::{parser::{Statement, Operand, TypeTag}, opcodes::{OPCODE_MAP, Opcode}};

grammar;

match {
    r"\s*" => { }, // Ignore whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Ignore // comments
    _,
} 

// The top level collection of statements, 
pub Statements: Vec<Statement> = {
    <ls:LabelOrStatement*> <s:Statement?> => ls.into_iter().flatten().chain(s.into_iter()).collect(), 
}

LabelOrStatement: Option<Statement> = {
    Label => Some(<>),
    <Statement?> ";" => <>
}

Statement: Statement = {
    OpcodeStatement => <>,
    MacroStatement => <>,
    MacroInvocation => <>,
}

// TODO: parameters for macros
MacroStatement: Statement = {
    ".macro" <name:Identifier> "{" <statements:Statements> "}" => Statement::MacroStatement(name, statements),
}

MacroInvocation: Statement = {
    "$" <name:Identifier> => Statement::MacroInvocation(name),
}

Label: Statement = {
    <Identifier> ":" => Statement::Label(<>),
}


// Opcode usage
OpcodeStatement: Statement = {
    // TODO: i feel that this could be trying to be too dynamic, do NOT remove this todo until solved
    <opcode:GetOpcode> <operands:Operand*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/false, operands, None),
    <opcode:GetOpcode> "@"<label:Identifier> <operands:Operand*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/false, operands, Some(label)),
    <opcode:GetOpcode> "!" <operands:Operand*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/true, operands, None),
}

GetOpcode: Opcode = {
    <opcode:Identifier> => {
        let opcode = OPCODE_MAP.get(&opcode.to_lowercase()).expect("unknown opcode");
        opcode.clone()
    }
}

Identifier: String = r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>);

Operand: Operand = {
    HexLiteral => Operand::Hex(<>),
    DecimalLiteral => Operand::Decimal(<>), 
    TypeTagLiteral => Operand::Tag(<>),
}

TypeTagLiteral: TypeTag = {
    "u8" => TypeTag::U8,
    "u16" => TypeTag::U16,
    "u32" => TypeTag::U32,
    "u64" => TypeTag::U64,
    "u128" => TypeTag::U128,
    "ff" => TypeTag::FF,
}

HexLiteral: String = r"0x[a-f0-9]+" => String::from(<>);

// Number definition
DecimalLiteral: u64 = <s:r"[0-9]+"> => u64::from_str(s).unwrap();
