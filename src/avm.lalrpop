use std::str::FromStr;
use crate::{parser::Statement, opcodes::{OPCODE_MAP, Opcode}};

grammar;


// The top level collection of statements, 
pub Statements: Vec<Statement> = {
    <ls:LabelOrStatement*> <s:Statement?> => ls.into_iter().flatten().chain(s.into_iter()).collect(), 
}

LabelOrStatement: Option<Statement> = {
    Label => Some(<>),
    <Statement?> ";" => <>
}

Statement: Statement = {
    OpcodeStatement => <>,
    MacroStatement => <>,
    MacroInvocation => <>,
}

// TODO: parameters for macros
MacroStatement: Statement = {
    ".macro" <name:Identifier> "{" <statements:Statements> "}" => Statement::MacroStatement(name, statements),
}

MacroInvocation: Statement = {
    "$" <name:Identifier> => Statement::MacroInvocation(name),
}

Label: Statement = {
    <Identifier> ":" => Statement::Label(<>),
    <Number> ":" => Statement::Label(<>.to_string())
}


// Opcode usage
OpcodeStatement: Statement = {
    // TODO: i feel that this could be trying to be too dynamic, do NOT remove this todo until solved
    <opcode:GetOpcode> <operands:Number*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/false, operands, None),
    <opcode:GetOpcode> "@"<label:Identifier> <operands:Number*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/false, operands, Some(label)),
    <opcode:GetOpcode> "!" <operands:Number*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/true, operands, None),
}

GetOpcode: Opcode = {
    <opcode:Identifier> => {
        let opcode = OPCODE_MAP.get(&opcode.to_lowercase()).expect("unknown opcode");
        opcode.clone()
    }
}

Identifier: String = r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>);

// Number definition
Number: u64 = {
    // TODO: check bit sizes in this case
    r"[0-9]*" => u64::from_str(<>).unwrap() as u64,
}