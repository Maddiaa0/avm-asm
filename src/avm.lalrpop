use std::str::FromStr;
use crate::{parser::Statement, opcodes::{OPCODE_MAP, Opcode}};

grammar;


// The top level collection of statements, 
pub Statements: Vec<Statement> = {
    <ls:LabelOrStatement*> <s:Statement?> => ls.into_iter().flatten().chain(s.into_iter()).collect(), 
}

LabelOrStatement: Option<Statement> = {
    Label => Some(<>),
    <Statement?> ";" => <>
}

Statement: Statement = {
    OpcodeStatement => <>,
}

Label: Statement = {
    <Identifier> ":" => Statement::Label(<>),
    <Number> ":" => Statement::Label(<>.to_string())
}

// Opcode usage
OpcodeStatement: Statement = {
    <opcode:GetOpcode> <operands:Number*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/false, operands),
    <opcode:GetOpcode> "!" <operands:Number*> => Statement::OpcodeStatement(opcode.clone(), /*indirect=*/true, operands),
}

GetOpcode: Opcode = {
    <opcode:Identifier> => {
        let opcode = OPCODE_MAP.get(&opcode.to_lowercase()).expect("unknown opcode");
        opcode.clone()
    }
}

Identifier: String = r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>);

// Number definition
Number: u64 = {
    // TODO: check bit sizes in this case
    r"[0-9]*" => u64::from_str(<>).unwrap() as u64,
}